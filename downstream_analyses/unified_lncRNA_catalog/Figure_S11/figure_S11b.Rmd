░██████████░██                                               ░██████     ░██     ░██   ░██        
░██                                                         ░██   ░██  ░████   ░████   ░██        
░██        ░██ ░████████ ░██    ░██ ░██░████  ░███████     ░██           ░██     ░██   ░████████  
░█████████ ░██░██    ░██ ░██    ░██ ░███     ░██    ░██     ░████████    ░██     ░██   ░██    ░██ 
░██        ░██░██    ░██ ░██    ░██ ░██      ░█████████            ░██   ░██     ░██   ░██    ░██ 
░██        ░██░██   ░███ ░██   ░███ ░██      ░██            ░██   ░██    ░██     ░██   ░███   ░██ 
░██        ░██ ░█████░██  ░█████░██ ░██       ░███████       ░██████   ░██████ ░██████ ░██░█████  
                     ░██                                                                          
               ░███████                                                                           

# Prepare environment and run tmerge
```{bash echo=FALSE, engine.opts='-l'}
# Remove old results
rm -r .temp_s11b/
rm figure_s11b_targets_input.tsv
rm figure_s11b_recount_input.tsv

# Handle errors
set -e          # exit on any non-0 exit status
set -o pipefail # exit on any non-0 exit status in pipe

# Create directory tree
mkdir .temp_s11b/
mkdir .temp_s11b/M_catalogs/
mkdir .temp_s11b/M_tmerged/

# Move to working dir
cd .temp_s11b/

# Copy necessary files
## Full Gencode.v47 annotation
zcat ../../Data/Additional/gencode.vM36.chr_patch_hapl_scaff.annotation.gtf.gz > gencode.vM36.chr_patch_hapl_scaff.annotation.gtf
## Full mT
cp ../../Data/masterTable/Mv2_masterTable_refined.gtf.gz .
## Spliced mT
cp ../../Data/masterTable/Mv2_splicedmasterTable_refined.gtf.gz .
# samplesMetadata
cp ../../Data/masterTable/Mv2_metadata.tsv.gz .
# TargetDesign
cp ../../Data/masterTable/Mv2_CLS3_targetDesign.gtf.gz .
# Mouse Catalogs (only main chr, exclude chrM)
## longNonCoding
### non-lifted
zcat ../../Data/M_catalogs/gencodeM3+.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/gencodeM3+.mm10.bed12
zcat ../../Data/M_catalogs/NONCODE.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/NONCODE.mm10.bed12
zcat ../../Data/M_catalogs/refSeq.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/refSeq.mm10.bed12
### lifted from hg38 to mm10
zcat ../../Data/M_catalogs/bigTranscriptome.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/bigTranscriptome.mm10.bed12
zcat ../../Data/M_catalogs/fantomCat.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/fantomCat.mm10.bed12
zcat ../../Data/M_catalogs/miTranscriptome.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/miTranscriptome.mm10.bed12
## smallNonCoding
zcat ../../Data/M_catalogs/miRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/miRNA.mm10.bed12
zcat ../../Data/M_catalogs/snoRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/snoRNA.mm10.bed12
zcat ../../Data/M_catalogs/snRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/snRNA.mm10.bed12
## putative
zcat ../../Data/M_catalogs/CMfinderCRSs.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$5="0"' | awk -F"\t" '{OFS=FS}$4="CMfinderCRSs."$4"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./M_catalogs/CMfinderCRSs.mm10.bed12
zcat ../../Data/M_catalogs/GWAScatalog.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | awk -F"\t" '{OFS=FS}$4="GWAScatalog."$4"."$6"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./M_catalogs/GWAScatalog.mm10.bed12
zcat ../../Data/M_catalogs/phyloCSF.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$4="phyloCSF."$4"."$1"."$2"."$3"."$6' > ./M_catalogs/phyloCSF.mm10.bed12
zcat ../../Data/M_catalogs/UCE.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | awk -F"\t" '{OFS=FS}$4="UCE."$4"."$6"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./M_catalogs/UCE.mm10.bed12
## enhancers
zcat ../../Data/M_catalogs/fantomEnhancers.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./M_catalogs/fantomEnhancers.mm10.bed12
zcat ../../Data/M_catalogs/VISTAenhancers.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./M_catalogs/VISTAenhancers.mm10.bed12

## Extract target_ids detected in mT
### Extract target_ids with artifact tags
zcat Mv2_masterTable_refined.gtf.gz | extract.gtf.tags.sh - target,artifact | grep "\S" | gzip > Mv2_masterTable_refined_targets_with_artifacts.tsv.gz
### Extract genuine target_ids
zcat Mv2_masterTable_refined_targets_with_artifacts.tsv.gz | awk '$2=="no"{print$1}' | sed 's/,/\n/g' | sort | uniq | grep "\S" > Mv2_masterTable_refined_genuine_target.ids

################
# longNonCoding
################
# Create list of all catalog transcript ids (not only main chr etc.)
## for diagnostics only
zcat ../../Data/M_catalogs/bigTranscriptome.gtf.gz ../../Data/M_catalogs/fantomCat.gtf.gz ../../Data/M_catalogs/gencodeM3+.gtf.gz ../../Data/M_catalogs/miTranscriptome.gtf.gz ../../Data/M_catalogs/NONCODE.gtf.gz ../../Data/M_catalogs/refSeq.gtf.gz | ../../Utils/gff2bed_full.pl - | awk '{print $4}' | sort | uniq > temp.M_concat_longNonCoding.tx.ids
# Transform data
## Concatenate mouse catalogs into 1 file ();
### All catalogs
cat ./M_catalogs/bigTranscriptome.mm10.bed12 ./M_catalogs/fantomCat.mm10.bed12 ./M_catalogs/gencodeM3+.mm10.bed12 ./M_catalogs/miTranscriptome.mm10.bed12 ./M_catalogs/NONCODE.mm10.bed12 ./M_catalogs/refSeq.mm10.bed12 | sort | uniq | grep "\S" > ./M_catalogs/M_concat_all_longNonCoding.mm10.bed12
### Only non-lifted
cat ./M_catalogs/gencodeM3+.mm10.bed12 ./M_catalogs/NONCODE.mm10.bed12 ./M_catalogs/refSeq.mm10.bed12 | sort | uniq | grep "\S" > ./M_catalogs/M_concat_true_longNonCoding.mm10.bed12

## Extracting target_ids from targetDesign (take only long-nonCoding catalogs, cuz other ids are messed up after stripping - eg. can strip to: "1000")
zcat Mv2_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="longNonCoding"{print$1}' | sort | uniq | grep "\S" | gzip > Mv2_longNonCoding_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check, loop and recount block
zcat Mv2_longNonCoding_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Mv2_targeted_longNonCoding_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Mv2_longNonCoding_targets.ids.gz | grep -Fwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > M_longNonCoding_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Mv2_longNonCoding_targets.ids.gz | grep -vFwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" > M_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Mv2_targeted_longNonCoding_tx.ids | grep -vFwf temp.M_concat_longNonCoding.tx.ids > Mv2_MISSING_targeted_longNonCoding_tx.ids
missed_tx_ids=`cat Mv2_MISSING_targeted_longNonCoding_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi
#set -e

## Prepare longNonCoding config file
for file in `ls ./M_catalogs/*mm10.bed12 | grep -E 'gencodeM3+|NONCODE|refSeq|M_concat_true_longNonCoding|M_concat_all_longNonCoding|miTranscriptome|bigTranscriptome|fantomCat'`; do echo $file >> M_longNonCoding.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./M_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./M_tmerged/$name.tmerged.gtf.gz | grep -Fwf Mv2_targeted_longNonCoding_tx.ids | grep "\S" | gzip > ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.vM36
    # Temporary decompress files
    zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.vM36)
    cat $file | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="longNonCoding"
    all_IC=`zcat ./M_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Mv2_targeted_longNonCoding_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf M_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> ../figure_s11b_targets_input.tsv
    echo "++ Done ++"
  done < ./M_longNonCoding.config
  
  
################
# smallNonCoding
################  
# Create list of all catalog transcript ids (not only main chr etc.)
## for diagnostics only
zcat ../../Data/M_catalogs/miRNA.bed.gz ../../Data/M_catalogs/snoRNA.bed.gz ../../Data/M_catalogs/snRNA.bed.gz | awk '{print $4}' | sort | uniq > temp.M_concat_smallNonCoding.tx.ids
# Transform data
## Concatenate mouse catalogs into 1 file ();
cat ./M_catalogs/miRNA.mm10.bed12 ./M_catalogs/snoRNA.mm10.bed12 ./M_catalogs/snRNA.mm10.bed12 | sort | uniq | grep "\S" > ./M_catalogs/M_concat_smallNonCoding.mm10.bed12

## Extracting target_ids from targetDesign (take only small-nonCoding catalogs, cuz other ids are messed up after stripping - eg. can strip to: "1000")
zcat Mv2_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="smallNonCoding"{print$1}' | sort | uniq | grep "\S" | gzip > Mv2_smallNonCoding_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
zcat Mv2_smallNonCoding_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Mv2_targeted_smallNonCoding_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Mv2_smallNonCoding_targets.ids.gz | grep -Fwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > M_smallNonCoding_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Mv2_smallNonCoding_targets.ids.gz | grep -vFwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf M_smallNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" > M_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Mv2_targeted_smallNonCoding_tx.ids | grep -vFwf temp.M_concat_smallNonCoding.tx.ids > Mv2_MISSING_targeted_smallNonCoding_tx.ids
missed_tx_ids=`cat Mv2_MISSING_targeted_smallNonCoding_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi

## Prepare smallNonCoding config file
for file in `ls ./M_catalogs/*mm10.bed12 | grep -E 'miRNA|snoRNA|snRNA'`; do echo $file >> M_smallNonCoding.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./M_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./M_tmerged/$name.tmerged.gtf.gz | grep -Fwf Mv2_targeted_smallNonCoding_tx.ids | grep "\S" | gzip > ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_smallNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.vM36
    # Temporary decompress files
    zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.vM36)
    cat $file | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="smallNonCoding"
    all_IC=`zcat ./M_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Mv2_targeted_smallNonCoding_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf M_smallNonCoding_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf M_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> ../figure_s11b_targets_input.tsv
    echo "++ Done ++"
  done < ./M_smallNonCoding.config


################
# putative
################
# Create list of all catalog transcript ids (not only main chr etc.)
## for diagnostics only
zcat ../../Data/M_catalogs/CMfinderCRSs.bed.gz ../../Data/M_catalogs/GWAScatalog.bed.gz ../../Data/M_catalogs/phyloCSF.bed.gz ../../Data/M_catalogs/UCE.bed.gz | awk '{print $4}' | sort | uniq > temp.M_concat_putative.tx.ids
# Transform data
## Concatenate mouse catalogs into 1 file ();
cat ./M_catalogs/CMfinderCRSs.mm10.bed12 ./M_catalogs/GWAScatalog.mm10.bed12 ./M_catalogs/phyloCSF.mm10.bed12 ./M_catalogs/UCE.mm10.bed12 | sort | uniq | grep "\S" > ./M_catalogs/M_concat_putative.mm10.bed12

## Extracting target_ids from targetDesign (take only putative catalogs)
zcat Mv2_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="putative"{print$1}' | sort | uniq | grep "\S" | gzip > Mv2_putative_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
## Transcript ids are equal to target ids. Kept the filenames for compatibility
#zcat Mv2_putative_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Mv2_targeted_putative_tx.ids
zcat Mv2_putative_targets.ids.gz | sort | uniq | grep "\S" > Mv2_targeted_putative_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### As above, do not convert to transcript ids cuz target_id=transcript_id for putative. Names kept for consistency
### in genuine mT
#zcat Mv2_putative_targets.ids.gz | grep -Fwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > M_putative_tx_ids_detected_in_genuinemT.ids
zcat Mv2_putative_targets.ids.gz | grep -Fwf Mv2_masterTable_refined_genuine_target.ids | sort | uniq | grep "\S" > M_putative_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### As above, do not convert to transcript ids cuz target_id=transcript_id for putative. Names kept for consistency
### in genuine mT
### There are no transcripts/exons. Only regions. 1 region = 1 target
#zcat Mv2_putative_targets.ids.gz | grep -vFwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf M_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" > M_putative_tx_ids_NOTdetected_in_genuinemT.ids
zcat Mv2_putative_targets.ids.gz | grep -vFwf Mv2_masterTable_refined_genuine_target.ids | sort | uniq | grep -vFwf M_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" > M_putative_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Mv2_targeted_putative_tx.ids | grep -vFwf temp.M_concat_putative.tx.ids > Mv2_MISSING_targeted_putative_tx.ids
missed_tx_ids=`cat Mv2_MISSING_targeted_putative_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi

## Prepare putative config file
for file in `ls ./M_catalogs/*mm10.bed12 | grep -E 'CMfinderCRSs|GWAScatalog|phyloCSF|UCE'`; do echo $file >> M_putative.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./M_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./M_tmerged/$name.tmerged.gtf.gz | grep -Fwf Mv2_targeted_putative_tx.ids | grep "\S" | gzip > ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_putative_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.vM36
    # Temporary decompress files
    zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.vM36)
    cat $file | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="putative"
    all_IC=`zcat ./M_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Mv2_targeted_putative_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf M_putative_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf M_putative_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> ../figure_s11b_targets_input.tsv
    echo "++ Done ++"
  done < ./M_putative.config
  
  
################
# enhancers
################
# Create list of all catalog transcript ids (not only main chr etc.)
## for diagnostics only
zcat ../../Data/M_catalogs/fantomEnhancers.bed.gz ../../Data/M_catalogs/VISTAenhancers.bed.gz | awk '{print $4}' | sort | uniq > temp.M_concat_enhancers.tx.ids
# Transform data
## Concatenate mouse catalogs into 1 file ();
cat ./M_catalogs/fantomEnhancers.mm10.bed12 ./M_catalogs/VISTAenhancers.mm10.bed12 | sort | uniq | grep "\S" > ./M_catalogs/M_concat_enhancers.mm10.bed12

## Extracting target_ids from targetDesign (take only enhancers catalogs)
zcat Mv2_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="enhancers"{print$1}' | sort | uniq | grep "\S" | gzip > Mv2_enhancers_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
zcat Mv2_enhancers_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Mv2_targeted_enhancers_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Mv2_enhancers_targets.ids.gz | grep -Fwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > M_enhancers_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Mv2_enhancers_targets.ids.gz | grep -vFwf Mv2_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf M_enhancers_tx_ids_detected_in_genuinemT.ids | grep "\S" > M_enhancers_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Mv2_targeted_enhancers_tx.ids | grep -vFwf temp.M_concat_enhancers.tx.ids > Mv2_MISSING_targeted_enhancers_tx.ids
missed_tx_ids=`cat Mv2_MISSING_targeted_enhancers_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi

## Prepare enhancers config file
for file in `ls ./M_catalogs/*mm10.bed12 | grep -E 'fantomEnhancers|VISTAenhancers'`; do echo $file >> M_enhancers.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./M_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./M_tmerged/$name.tmerged.gtf.gz | grep -Fwf Mv2_targeted_enhancers_tx.ids | grep "\S" | gzip > ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_enhancers_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf M_enhancers_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.vM36
    # Temporary decompress files
    zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.vM36)
    cat $file | grep -Fwf M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.vM36.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="enhancers"
    all_IC=`zcat ./M_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./M_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Mv2_targeted_enhancers_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf M_enhancers_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf M_enhancers_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> ../figure_s11b_targets_input.tsv
    echo "++ Done ++"
  done < ./M_enhancers.config


###################################
# Run recount analysis
###################################  

# Remove old results
rm -r Recount/

# Create directory tree
mkdir Recount/
mkdir Recount/M_catalogs_gtf/

# Move to working dir
cd Recount/

# Copy necessary files
## recount data from Tamara
zcat ../../../Data/Additional/m38_recount3.bed.gz | awk '{print $1"\t"$2+1"\t"$3"\t"$5"\t"$6}' > m38_recount3.pseudo.bed

set +e
## Catalogs from above intronChain part and convert to gff + add some processed stuff
for file in `ls ../M_catalogs/*.mm10.bed12 | grep -E 'gencodeM3+|NONCODE|refSeq|M_concat_true_longNonCoding|M_concat_all_longNonCoding|miTranscriptome|bigTranscriptome|fantomCat'`
  do
    echo $file
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    # All tx
    cat $file | ../../../Utils/bed12togff - | gzip > ./M_catalogs_gtf/$name.gtf.gz
    # All ic
    cp ../M_tmerged/$name.tmerged.gtf.gz ./M_catalogs_gtf/${name}_tmerged.gtf.gz
    # Targeted tx
    cat $file | grep -Fwf ../Mv2_targeted_longNonCoding_tx.ids | grep "\S" | ../../../Utils/bed12togff - | gzip > ./M_catalogs_gtf/${name}_targeted_slice.gtf.gz
    # Targeted ic
    cp ../M_tmerged/$name.targeted.slice.tmerged.gtf.gz ./M_catalogs_gtf/${name}_targeted_slice_tmerged.gtf.gz
    # Detected genuine tx
    cat $file | grep -Fwf ../M_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../../Utils/bed12togff - | gzip > ./M_catalogs_gtf/${name}_detectedInGenuine_slice.gtf.gz
    # Detected genuine ic
    cp ../M_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz ./M_catalogs_gtf/${name}_detectedInGenuine_slice_tmerged.gtf.gz
    # Detected genuine tx GENCODE
    ## Prepare slice
    zcat ./M_catalogs_gtf/${name}_detectedInGenuine_slice.gtf.gz | grep -Fwf ../${name}_TX_detected_GENCODE.ids | gzip > ./M_catalogs_gtf/${name}_detectedInGenuine_slice_GENCODE.gtf.gz
    # Detected genuine ic GENCODE
    ## Prepare slice
    zcat ./M_catalogs_gtf/${name}_detectedInGenuine_slice_tmerged.gtf.gz | grep -Fwf ../${name}_IC_detected_GENCODE.ids | gzip > ./M_catalogs_gtf/${name}_detectedInGenuine_slice_tmerged_GENCODE.gtf.gz
    # NOT Detected genuine tx
    cat $file | grep -Fwf ../M_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | ../../../Utils/bed12togff - | gzip > ./M_catalogs_gtf/${name}_NOTdetectedInGenuine_slice.gtf.gz
    # NOT Detected genuine ic
    cp ../M_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz ./M_catalogs_gtf/${name}_NOTdetectedInGenuine_slice_tmerged.gtf.gz
  done

## Create new config file
for catalogue in `ls ./M_catalogs_gtf/*gtf.gz | grep -E 'gencodeM3+|NONCODE|refSeq|M_concat_true_longNonCoding|M_concat_all_longNonCoding|miTranscriptome|bigTranscriptome|fantomCat'`; do echo $catalogue >> M_recount.config; done

while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    
    echo "~~~ Preparing introns ~~~"
      # For introns to be compatible with recount data, they need to be modified: start+1 stop-1
      # I included this in modified version on make_introns.awk script
      zcat $file | sort -k12,12 -k4,4n -k5,5n - | awk -v fldgn=10 -v fldtr=12 -f ../../../Utils/make_introns_for_recount.awk | awk '{print $1"\t"$4"\t"$5"\t"$7"\t"$12}' | sed 's/;//g' | sed 's/"//g' > $name.introns
      echo "+++ Done +++"
      echo "~~~ Right-outer joining recount data with $name introns  ~~~"
      # Right-outer join seems easier for join.py script than left-outer join which is I guess not supported
      # Results are as expected, but be sure that u submit recount as "file a"
      ../../../Utils/join.py -a m38_recount3.pseudo.bed -b $name.introns -x 1,2,3,5 -y 1,2,3,4 -u > ${name}_with_recount.tsv
      # Calculate supported and unsupported tx - percentage is always calculated for tx that have introns
      total_tx=`cat $name.introns | awk '{print $5}' | sort | uniq | wc -l`
      # Fortunately as < 50 awk prints also "-" that were assigned to unmatched introns
      not_supported_tx=`cat ${name}_with_recount.tsv | awk '$6 < 50 {print $5}' | sort | uniq | wc -l`
      supported_tx=$((total_tx-not_supported_tx))
      supported_tx_percentage=`echo "scale=2 ; $supported_tx / $total_tx" | bc`
      # Save results to tsv
      echo -e "$name\t$total_tx\t$supported_tx\t$not_supported_tx\t$supported_tx_percentage" >> ../../figure_s11b_recount_input.tsv
      echo "+++ Done +++"    
  done < ./M_recount.config  
```

# Load R libraries
```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(ggplot2,
               scales,
               dplyr,
               tidyr,
               ggrepel,
               ggh4x)
```

# Load and analyze data <- purple plots
```{r}
# Clean the env
rm(list = ls())

# Define color palette
color_palette <- c("#543D7B", "#6D5593", "#968EAF", "#546DA6", "#BBC1C6")

non_lifted_catalogs <- c("GENCODEv20+", "NONCODE", "refSeq", "Unique transcripts",
                         "phyloCSF",
                         "miRNA", "snoRNA", "snRNA")

# Load data
df_M_intronChains_target_detection <- read.table("figure_s11b_targets_input.tsv", header=F, sep="\t") %>%
  rename(M_target_category="V1",
         M_catalog_name="V2",
         M_all_ic="V3",
         M_all_tx="V4",
         M_targeted_ic="V5",
         M_targeted_tx="V6",
         M_detected_genuine_ic="V7",
         M_detected_genuine_ic_gencode="V8",
         M_NOTdetected_genuine_ic="V9",
         M_detected_genuine_tx="V10",
         M_detected_genuine_tx_gencode="V11",
         M_NOTdetected_genuine_tx="V12")

# Pivot the data for easier plotting
df_M_intronChains_target_detection %>% 
  select(M_target_category, M_catalog_name, M_all_ic, M_targeted_ic, M_detected_genuine_ic, M_detected_genuine_ic_gencode, M_NOTdetected_genuine_ic) %>%  
  mutate(M_catalog_name=sub("M_concat_all_longNonCoding*", "mergedCatalogsALL", M_catalog_name)) %>%
  mutate(M_catalog_name=sub("M_concat_true_longNonCoding*", "mergedCatalogs", M_catalog_name)) %>%
  rename(all="M_all_ic",
         targeted="M_targeted_ic",
         detected_genuine="M_detected_genuine_ic",
         detected_genuine_vM36="M_detected_genuine_ic_gencode",
         NOTdetected_genuine="M_NOTdetected_genuine_ic") %>% 
  mutate(M_type="intronChains") %>% 
  tidyr::pivot_longer(
     cols = c("all", "targeted", "detected_genuine", "detected_genuine_vM36", "NOTdetected_genuine"),
     names_to = "M_status",
     values_to = "M_count") -> df_M_intronChains_target_detection_IC
  
# Preview
df_M_intronChains_target_detection
df_M_intronChains_target_detection_IC

#--------------------------------

# Read recount data
df_recount_support <- read.table("figure_s11b_recount_input.tsv", header=F, sep="\t") %>%
  rename(M_catalog_name="V1",
         total_tx="V2",
         supported_tx="V3",
         not_supported_tx="V4",
         supported_tx_percentage="V5") %>% 
  rowwise() %>%
  mutate(M_catalog_name=sub("M_concat_all_longNonCoding*", "mergedCatalogsALL", M_catalog_name)) %>%
  mutate(M_catalog_name=sub("M_concat_true_longNonCoding*", "mergedCatalogs", M_catalog_name)) %>%
  mutate(M_status=sub("^[^_]*_", "", M_catalog_name)) %>% 
  mutate(M_type=ifelse((M_status=="detectedInGenuine_slice_tmerged" |
                         M_status=="detectedInGenuine_slice_tmerged_GENCODE" |
                         M_status=="NOTdetectedInGenuine_slice_tmerged" |
                         M_status=="targeted_slice_tmerged" |
                         M_status=="tmerged"), "intronChains", "transcripts")) %>% 
  mutate(M_status=ifelse((M_status==M_catalog_name | M_status=="tmerged"), "all", M_status)) %>% 
  mutate(M_status=ifelse((M_status=="detectedInGenuine_slice" | M_status=="detectedInGenuine_slice_tmerged"), "detected_genuine", M_status)) %>%
  mutate(M_status=ifelse((M_status=="detectedInGenuine_slice_GENCODE" | M_status=="detectedInGenuine_slice_tmerged_GENCODE"), "detected_genuine_vM36", M_status)) %>%
  mutate(M_status=ifelse((M_status=="NOTdetectedInGenuine_slice" | M_status=="NOTdetectedInGenuine_slice_tmerged"), "NOTdetected_genuine", M_status)) %>%
  mutate(M_status=ifelse((M_status=="targeted_slice" | M_status=="targeted_slice_tmerged"), "targeted", M_status)) %>%
  mutate(M_catalog_name=sub("_.*", "", M_catalog_name)) %>% 
  select(M_catalog_name, supported_tx_percentage, M_status, M_type) %>% 
  rename(recount_support="supported_tx_percentage")

# Preview
df_recount_support


# Plot
df_M_intronChains_target_detection_IC %>%
  left_join(x=.,
            y=df_recount_support,
            by=c("M_catalog_name", "M_status", "M_type")) %>% 
  # Filter GENCODE data
  rowwise() %>% 
  mutate(M_status=ifelse((M_status=="detected_genuine"), "detected", M_status)) %>% #"GENCODE M36"
  mutate(M_status=ifelse((M_status=="detected_genuine_vM36"), "GENCODE vM36", M_status)) %>%
  mutate(M_status=ifelse((M_status=="NOTdetected_genuine"), "not detected", M_status)) %>%  #"NOT in GENCODE M36"
  # longNonCoding
  ## Concatenated
  mutate(M_catalog_name=ifelse(M_catalog_name=="mergedCatalogs", "Unique transcripts", M_catalog_name)) %>%
  mutate(M_catalog_name=ifelse(M_catalog_name=="mergedCatalogsALL", "Unique transcripts ALL", M_catalog_name)) %>%
  ## non-lifted
  mutate(M_catalog_name=ifelse(M_catalog_name=="gencodeM3+", "GENCODEv20+", M_catalog_name)) %>%
  mutate(M_catalog_name=ifelse(M_catalog_name=="noncode", "NONCODE", M_catalog_name)) %>%
  mutate(M_catalog_name=ifelse(M_catalog_name=="refseq", "refSeq", M_catalog_name)) %>%
  ## lifted
  mutate(M_catalog_name=ifelse(M_catalog_name=="mitrans", "miTranscriptome", M_catalog_name)) %>%
  mutate(M_catalog_name=ifelse(M_catalog_name=="fantomCat", "fantomCat", M_catalog_name)) %>%
  mutate(M_catalog_name=ifelse(M_catalog_name=="bigTranscriptome", "bigTranscriptome", M_catalog_name)) %>%
  # Add validation rate
  group_by(M_catalog_name) %>%
  mutate(M_validation_rate = (M_count[3] / M_count[2])) %>% 
  # Add some formatting nonsense
  mutate(M_target_category = ifelse((M_target_category == "longNonCoding"), "individual lncRNA catalogs", M_target_category)) %>% 
  mutate(M_lift_status = ifelse((M_catalog_name %in% non_lifted_catalogs), "non-lifted", "lifted from hg38")) %>% 
  mutate(M_target_category = ifelse(M_catalog_name=="Unique transcripts", "merged", M_target_category)) %>% 
  mutate(M_target_category = ifelse(M_catalog_name=="Unique transcripts ALL", "merged", M_target_category)) -> figure_s11b_input
  
# Calculate max to adjust plot
max_count_IC <- max(figure_s11b_input$M_count)

# Plot
figure_s11b_input %>% 
  ggplot(aes(x=reorder(M_catalog_name, -M_count),
             y=M_count,
             fill=factor(M_status, levels = c("all", "targeted", "detected", "GENCODE vM36", "not detected")))) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_text(aes(label = paste0(scales::comma(M_count),
                               ifelse((M_target_category=="individual lncRNA catalogs"
                                       | M_target_category=="merged"),
                                      (paste0(" ", "(", scales::percent(recount_support), ")")),
                                      paste0(""))),
                group = factor(M_status, levels = c("all", "targeted", "detected", "GENCODE vM36", "not detected")),
                y = ifelse((M_count < max_count_IC*0.8), M_count, M_count / 2),
                hjust = ifelse((M_count < max_count_IC*0.8),-0.1, 0.5)),
          position = position_dodge(width=0.9),
          vjust = 0.5,
          angle = 90,
          size = 3.0) +
  ## Add validation rate
  geom_text(aes(label = ifelse((M_status == "all"), paste0(scales::percent(M_validation_rate,
                                                                           accuracy = 0.01)), paste0("")),
                group = factor(M_status, levels = c("all", "targeted", "detected", "GENCODE vM36", "not detected")),
                y = max_count_IC*1.05),
          hjust = 0.5,
          vjust = 0.5,
          size = 3.0) +
  theme_bw() +
  ylab('# Intron chains') +
  scale_fill_manual(values=color_palette) +
  scale_y_continuous(labels = comma) +
  theme(axis.title.x = element_blank(),,
        axis.text.x = element_text(colour = "black", size = 9, angle = 60, hjust = 1),
        axis.text.y = element_text(colour = "black", size = 9),
        axis.ticks = element_line(colour = "black"),
        panel.background = element_rect(fill = "white", colour = "grey50"),
        legend.title = element_blank(),
        legend.position = "top",
        panel.grid = element_blank(),
        plot.title = element_text(hjust = 0.5, size=11)) +
  facet_grid2(cols=vars(factor(M_target_category, levels=c("merged", "individual lncRNA catalogs",
                                                           "putative", "smallNonCoding", "enhancers")),
                        factor(M_lift_status, levels = c("non-lifted", "lifted from hg38"))),
              space = "free",
              shrink = TRUE,
              scales = "free") -> plot_figure_s11b


# Preview plot
plot_figure_s11b
```

# Save as pdf
```{r}
pdf(file="figure_s11b.pdf", width = 18, height = 6)
plot_figure_s11b
```
