
░██████████░██                                               ░██████     ░██    ░██████  ░██        
░██                                                         ░██   ░██  ░████   ░██   ░██ ░██        
░██        ░██ ░████████ ░██    ░██ ░██░████  ░███████     ░██           ░██         ░██ ░████████  
░█████████ ░██░██    ░██ ░██    ░██ ░███     ░██    ░██     ░████████    ░██     ░█████  ░██    ░██ 
░██        ░██░██    ░██ ░██    ░██ ░██      ░█████████            ░██   ░██    ░██      ░██    ░██ 
░██        ░██░██   ░███ ░██   ░███ ░██      ░██            ░██   ░██    ░██   ░██       ░███   ░██ 
░██        ░██ ░█████░██  ░█████░██ ░██       ░███████       ░██████   ░██████ ░████████ ░██░█████  
                     ░██                                                                            
               ░███████                                                                             
                                                                                                    
# Prepare environment and run tmerge
```{bash echo=FALSE, engine.opts='-l'}
# Remove old results
rm -r .temp_s12b/

# Handle errors
set -e          # exit on any non-0 exit status
set -o pipefail # exit on any non-0 exit status in pipe

# Create directory tree
mkdir .temp_s12b/
mkdir .temp_s12b/H_catalogs/
mkdir .temp_s12b/H_tmerged/

# Move to working dir
cd .temp_s12b/

# Copy necessary files
## Full Gencode.v47 annotation
zcat ../../Data/Additional/gencode.v47.chr_patch_hapl_scaff.annotation.gtf.gz > gencode.v47.chr_patch_hapl_scaff.annotation.gtf
## Full mT
cp ../../Data/masterTable/Hv3_masterTable_refined.gtf.gz .
## Spliced mT
cp ../../Data/masterTable/Hv3_splicedmasterTable_refined.gtf.gz .
# samplesMetadata
cp ../../Data/masterTable/Hv3_metadata.tsv.gz .
# TargetDesign
cp ../../Data/masterTable/Hv3_CLS3_targetDesign.gtf.gz .
# human Catalogs (only main chr, exclude chrM)
## longNonCoding
zcat ../../Data/H_catalogs/bigTranscriptome.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/bigTranscriptome.hg38.bed12
zcat ../../Data/H_catalogs/fantomCat.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/fantomCat.hg38.bed12
zcat ../../Data/H_catalogs/gencode20+.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/gencode20+.hg38.bed12
zcat ../../Data/H_catalogs/miTranscriptome.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/miTranscriptome.hg38.bed12
zcat ../../Data/H_catalogs/NONCODE.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/NONCODE.hg38.bed12
zcat ../../Data/H_catalogs/refSeq.gtf.gz | ../../Utils/gff2bed_full.pl - | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/refSeq.hg38.bed12
## smallNonCoding
zcat ../../Data/H_catalogs/miRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/miRNA.hg38.bed12
zcat ../../Data/H_catalogs/snoRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/snoRNA.hg38.bed12
zcat ../../Data/H_catalogs/snRNA.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/snRNA.hg38.bed12
## putative
zcat ../../Data/H_catalogs/CMfinderCRSs.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$5="0"' | awk -F"\t" '{OFS=FS}$4="CMfinderCRSs."$4"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./H_catalogs/CMfinderCRSs.hg38.bed12
zcat ../../Data/H_catalogs/GWAScatalog.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | awk -F"\t" '{OFS=FS}$4="GWAScatalog."$4"."$6"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./H_catalogs/GWAScatalog.hg38.bed12
zcat ../../Data/H_catalogs/phyloCSF.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$4="phyloCSF."$4"."$1"."$2"."$3"."$6' > ./H_catalogs/phyloCSF.hg38.bed12
zcat ../../Data/H_catalogs/UCE.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | awk -F"\t" '{OFS=FS}$4="UCE."$4"."$6"."$1"."$2"."$3"."$6' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./H_catalogs/UCE.hg38.bed12
## enhancers
zcat ../../Data/H_catalogs/fantomEnhancers.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' > ./H_catalogs/fantomEnhancers.hg38.bed12
zcat ../../Data/H_catalogs/VISTAenhancers.bed.gz | sort | uniq | awk '$1 ~ /^chr[0-9XY]{1,2}$/ {print $0}' | awk -F"\t" '{OFS=FS}$6="+",$5="0"' | ../../Utils/bed2gff.pl - | ../../Utils/gff2bed_full.pl - > ./H_catalogs/VISTAenhancers.hg38.bed12

## Extract target_ids detected in mT
### Extract target_ids with artifact tags
zcat Hv3_masterTable_refined.gtf.gz | extract.gtf.tags.sh - target,artifact | grep "\S" | gzip > Hv3_masterTable_refined_targets_with_artifacts.tsv.gz
### Extract genuine target_ids
zcat Hv3_masterTable_refined_targets_with_artifacts.tsv.gz | awk '$2=="no"{print$1}' | sed 's/,/\n/g' | sort | uniq | grep "\S" > Hv3_masterTable_refined_genuine_target.ids

# Apparently it would be much easier to process categories one by one (not all at once)
################
# longNonCoding
################
# Create list of all catalog transcript ids (not only main chr etc.)
## For diagnostics only
zcat ../../Data/H_catalogs/bigTranscriptome.gtf.gz ../../Data/H_catalogs/fantomCat.gtf.gz ../../Data/H_catalogs/gencode20+.gtf.gz ../../Data/H_catalogs/miTranscriptome.gtf.gz ../../Data/H_catalogs/NONCODE.gtf.gz ../../Data/H_catalogs/refSeq.gtf.gz | ../../Utils/gff2bed_full.pl - | awk '{print $4}' | sort | uniq > temp.H_concat_longNonCoding.tx.ids
# Transform data
## Concatenate human catalogs into 1 file (remove tx with inconsistent strand);
### Only non-lifted (so for human - all catalogs)
cat ./H_catalogs/bigTranscriptome.hg38.bed12 ./H_catalogs/fantomCat.hg38.bed12 ./H_catalogs/gencode20+.hg38.bed12 ./H_catalogs/miTranscriptome.hg38.bed12 ./H_catalogs/NONCODE.hg38.bed12 ./H_catalogs/refSeq.hg38.bed12 | sort | uniq | grep -vFw "ENST00000610119.1" | grep "\S" > ./H_catalogs/H_concat_true_longNonCoding.hg38.bed12

## Extracting target_ids from targetDesign (take only long-nonCoding catalogs, cuz other ids are messed up after stripping - eg. can strip to: "1000")
zcat Hv3_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="longNonCoding"{print$1}' | sort | uniq | grep "\S" | gzip > Hv3_longNonCoding_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check, loop and recount block
zcat Hv3_longNonCoding_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Hv3_targeted_longNonCoding_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Hv3_longNonCoding_targets.ids.gz | grep -Fwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > H_longNonCoding_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Hv3_longNonCoding_targets.ids.gz | grep -vFwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf H_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" > H_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Hv3_targeted_longNonCoding_tx.ids | grep -vFwf temp.H_concat_longNonCoding.tx.ids > Hv3_MISSING_targeted_longNonCoding_tx.ids
missed_tx_ids=`cat Hv3_MISSING_targeted_longNonCoding_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi
#set -e

## Prepare longNonCoding config file
for file in `ls ./H_catalogs/*hg38.bed12 | grep -E 'gencode20+|NONCODE|refSeq|H_concat_true_longNonCoding|miTranscriptome|bigTranscriptome|fantomCat'`; do echo $file >> H_longNonCoding.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./H_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./H_tmerged/$name.tmerged.gtf.gz | grep -Fwf Hv3_targeted_longNonCoding_tx.ids | grep "\S" | gzip > ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.v47
    # Temporary decompress files
    zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.v47)
    cat $file | grep -Fwf H_longNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="longNonCoding"
    all_IC=`zcat ./H_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Hv3_targeted_longNonCoding_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf H_longNonCoding_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf H_longNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> H_target_detection_results.tsv
    echo "++ Done ++"
  done < ./H_longNonCoding.config
  
  
################
# smallNonCoding
################  
# Create list of all catalog transcript ids (not only main chr etc.)
## For diagnostics only
zcat  ../../Data/H_catalogs/miRNA.bed.gz ../../Data/H_catalogs/snoRNA.bed.gz ../../Data/H_catalogs/snRNA.bed.gz | awk '{print $4}' | sort | uniq > temp.H_concat_smallNonCoding.tx.ids
# Transform data
## Concatenate human catalogs into 1 file ();
cat ./H_catalogs/miRNA.hg38.bed12 ./H_catalogs/snoRNA.hg38.bed12 ./H_catalogs/snRNA.hg38.bed12 | sort | uniq | grep "\S" > ./H_catalogs/H_concat_smallNonCoding.hg38.bed12

## Extracting target_ids from targetDesign (take only small-nonCoding catalogs, cuz other ids are messed up after stripping - eg. can strip to: "1000")
zcat Hv3_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="smallNonCoding"{print$1}' | sort | uniq | grep "\S" | gzip > Hv3_smallNonCoding_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
zcat Hv3_smallNonCoding_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Hv3_targeted_smallNonCoding_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Hv3_smallNonCoding_targets.ids.gz | grep -Fwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > H_smallNonCoding_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Hv3_smallNonCoding_targets.ids.gz | grep -vFwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf H_smallNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" > H_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Hv3_targeted_smallNonCoding_tx.ids | grep -vFwf temp.H_concat_smallNonCoding.tx.ids > Hv3_MISSING_targeted_smallNonCoding_tx.ids
missed_tx_ids=`cat Hv3_MISSING_targeted_smallNonCoding_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi
#set -e

## Prepare smallNonCoding config file
for file in `ls ./H_catalogs/*hg38.bed12 | grep -E 'miRNA|snoRNA|snRNA'`; do echo $file >> H_smallNonCoding.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./H_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./H_tmerged/$name.tmerged.gtf.gz | grep -Fwf Hv3_targeted_smallNonCoding_tx.ids | grep "\S" | gzip > ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_smallNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.v47
    # Temporary decompress files
    zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.v47)
    cat $file | grep -Fwf H_smallNonCoding_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="smallNonCoding"
    all_IC=`zcat ./H_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Hv3_targeted_smallNonCoding_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf H_smallNonCoding_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf H_smallNonCoding_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> H_target_detection_results.tsv
    echo "++ Done ++"
  done < ./H_smallNonCoding.config


################
# putative
################
# Create list of all catalog transcript ids (not only main chr etc.)
## For diagnostics only
zcat ../../Data/H_catalogs/CMfinderCRSs.bed.gz ../../Data/H_catalogs/GWAScatalog.bed.gz ../../Data/H_catalogs/phyloCSF.bed.gz ../../Data/H_catalogs/UCE.bed.gz | awk '{print $4}' | sort | uniq > temp.H_concat_putative.tx.ids
# Transform data
## Concatenate human catalogs into 1 file ();
cat ./H_catalogs/CMfinderCRSs.hg38.bed12 ./H_catalogs/GWAScatalog.hg38.bed12 ./H_catalogs/phyloCSF.hg38.bed12 ./H_catalogs/UCE.hg38.bed12 | sort | uniq | grep "\S" > ./H_catalogs/H_concat_putative.hg38.bed12

## Extracting target_ids from targetDesign (take only putative catalogs)
zcat Hv3_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="putative"{print$1}' | sort | uniq | grep "\S" | gzip > Hv3_putative_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
## Transcript ids are equal to target ids. Kept the filenames for compatibility
#zcat Hv3_putative_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Hv3_targeted_putative_tx.ids
zcat Hv3_putative_targets.ids.gz | sort | uniq | grep "\S" > Hv3_targeted_putative_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### As above, do not convert to transcript ids cuz target_id=transcript_id for putative. Names kept for consistency
### in genuine mT
#zcat Hv3_putative_targets.ids.gz | grep -Fwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > H_putative_tx_ids_detected_in_genuinemT.ids
zcat Hv3_putative_targets.ids.gz | grep -Fwf Hv3_masterTable_refined_genuine_target.ids | sort | uniq | grep "\S" > H_putative_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### As above, do not convert to transcript ids cuz target_id=transcript_id for putative. Names kept for consistency
### in genuine mT
### There are no transcripts/exons. Only regions. 1 region = 1 target
#zcat Hv3_putative_targets.ids.gz | grep -vFwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf H_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" > H_putative_tx_ids_NOTdetected_in_genuinemT.ids
zcat Hv3_putative_targets.ids.gz | grep -vFwf Hv3_masterTable_refined_genuine_target.ids | sort | uniq | grep -vFwf H_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" > H_putative_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Hv3_targeted_putative_tx.ids | grep -vFwf temp.H_concat_putative.tx.ids > Hv3_MISSING_targeted_putative_tx.ids
missed_tx_ids=`cat Hv3_MISSING_targeted_putative_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi

## Prepare putative config file
for file in `ls ./H_catalogs/*hg38.bed12 | grep -E 'CMfinderCRSs|GWAScatalog|phyloCSF|UCE'`; do echo $file >> H_putative.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./H_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./H_tmerged/$name.tmerged.gtf.gz | grep -Fwf Hv3_targeted_putative_tx.ids | grep "\S" | gzip > ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_putative_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.v47
    # Temporary decompress files
    zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.v47)
    cat $file | grep -Fwf H_putative_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="putative"
    all_IC=`zcat ./H_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Hv3_targeted_putative_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf H_putative_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf H_putative_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> H_target_detection_results.tsv
    echo "++ Done ++"
  done < ./H_putative.config
  
  
################
# enhancers
################
# Create list of all catalog transcript ids (not only main chr etc.)
## For diagnostics only
zcat ../../Data/H_catalogs/fantomEnhancers.bed.gz ../../Data/H_catalogs/VISTAenhancers.bed.gz | awk '{print $4}' | sort | uniq > temp.H_concat_enhancers.tx.ids
# Transform data
## Concatenate human catalogs into 1 file ();
cat ./H_catalogs/fantomEnhancers.hg38.bed12 ./H_catalogs/VISTAenhancers.hg38.bed12 | sort | uniq | grep "\S" > ./H_catalogs/H_concat_enhancers.hg38.bed12

## Extracting target_ids from targetDesign (take only enhancers catalogs)
zcat Hv3_CLS3_targetDesign.gtf.gz | extract.gtf.tags.sh - target_id,target_category | awk '$2=="enhancers"{print$1}' | sort | uniq | grep "\S" | gzip > Hv3_enhancers_targets.ids.gz

## Extract transcript_ids that were targeted from target_ids (remove catalog name from first field and last 4 fields, fix broken mitrans ids ending with .+)
## For diagnostic check and loop
zcat Hv3_enhancers_targets.ids.gz | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > Hv3_targeted_enhancers_tx.ids

## Extract target_ids that belong to catalogs and were detected (and transform into tx_ids)
### in genuine mT
zcat Hv3_enhancers_targets.ids.gz | grep -Fwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep "\S" > H_enhancers_tx_ids_detected_in_genuinemT.ids

## Extract target_ids that belong to catalogs and were not detected (and transform into tx_ids)
### in genuine mT
### 1 exon = 1 target; some transcripts were only partially detected, so to avoid counting them as non detected we need to discard those partially detected
zcat Hv3_enhancers_targets.ids.gz | grep -vFwf Hv3_masterTable_refined_genuine_target.ids | awk -F'.' '{ OFS="."; for (i=2; i<=NF-4; i++) printf $i (i<NF-4?OFS:"\n") }' | sed 's/.+//g' | sort | uniq | grep -vFwf H_enhancers_tx_ids_detected_in_genuinemT.ids | grep "\S" > H_enhancers_tx_ids_NOTdetected_in_genuinemT.ids

## Check if all extracted ids may be found in catalogs
set +e
cat Hv3_targeted_enhancers_tx.ids | grep -vFwf temp.H_concat_enhancers.tx.ids > Hv3_MISSING_targeted_enhancers_tx.ids
missed_tx_ids=`cat Hv3_MISSING_targeted_enhancers_tx.ids | wc -l`
if [ $missed_tx_ids -gt 0 ]
then
    echo 'SOME OF THE TARGET_IDS WERE NOT CORRECTLY CONVERTED TO CATALOG TRANSCRIPT_IDS!!'
    echo "Detected $missed_tx_ids wrong entries!"
    exit 1
else
    echo 'Everything is fine. All target_ids were sucessfully converted to catalog transcript_ids.'
fi
#set -e

## Prepare enhancers config file
for file in `ls ./H_catalogs/*hg38.bed12 | grep -E 'fantomEnhancers|VISTAenhancers'`; do echo $file >> H_enhancers.config; done

## Tmerge transcripts to get non-redundant intronChains
while read file || [ -n "$file" ]
  do
    echo "~~~~ $file ~~~~"
    name=`echo $file | awk -F"/" '{print $3}' | awk -F"." '{print $1}'`
    echo "---- $name ----"
    echo "Tmerging..."
    cat $file | ../../Utils/bed12togff - | ../../Utils/sortgff - | ../../Utils/tmerge --exonOverhangTolerance 8 --tmPrefix IC - | grep '\S' | gzip > ./H_tmerged/$name.tmerged.gtf.gz
    echo "Preparing tmerged targeted slice..."
    zcat ./H_tmerged/$name.tmerged.gtf.gz | grep -Fwf Hv3_targeted_enhancers_tx.ids | grep "\S" | gzip > ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz
    echo "Preparing tmerged detected in genuine mT slice..."
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_enhancers_tx_ids_detected_in_genuinemT.ids | grep "\S" | gzip > ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    echo "Preparing tmerged NOT detected in genuine mT slice..."
    gzip -dk ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz
    zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | grep -Fwf H_enhancers_tx_ids_NOTdetected_in_genuinemT.ids | grep "\S" | grep -vFwf ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf | grep '\S' | gzip > ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz
    rm ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf
    echo "Running gffcompare..."
    # Find which of the detected TX/IC are in GENCODE.v47
    # Temporary decompress files
    zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz > $name.detectedInGenuine.slice.tmerged.gtf
    # Convert catalogs to gtf (to calculate detected_in_genuinde_TX in GENCODE.v47)
    cat $file | grep -Fwf H_enhancers_tx_ids_detected_in_genuinemT.ids | grep "\S" | ../../Utils/bed12togff - > $name.detectedInGenuine.slice.gtf
    # Run gffcompare
    gffcompare -o ${name}_IC -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.tmerged.gtf
    gffcompare -o ${name}_TX -r gencode.v47.chr_patch_hapl_scaff.annotation.gtf $name.detectedInGenuine.slice.gtf
    # Extract only Equal, Included, Extends and Overlaps classes (according to simplifyGffCompareClasses.pl)
    cat ${name}_IC.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_IC_detected_GENCODE.ids
    cat ${name}_TX.tracking | ../../Utils/simplifyGffCompareClasses.pl - | grep -wE "Equal|Included|Extends|Overlaps" | awk '!seen[$1]++{print$1}' | grep "\S" > ${name}_TX_detected_GENCODE.ids
    # Remove decompressed files
    rm $name.detectedInGenuine.slice.tmerged.gtf
    echo "Adding numbers to the output file..."
    target_category="enhancers"
    all_IC=`zcat ./H_tmerged/$name.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    all_TX=`cat $file | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    targeted_IC=`zcat ./H_tmerged/$name.targeted.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    targeted_TX=`cat $file | grep -Fwf Hv3_targeted_enhancers_tx.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC=`zcat ./H_tmerged/$name.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    detected_genuine_TX=`cat $file | grep -Fwf H_enhancers_tx_ids_detected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    detected_genuine_IC_GENCODE=`cat ${name}_IC_detected_GENCODE.ids | wc -l`
    detected_genuine_TX_GENCODE=`cat ${name}_TX_detected_GENCODE.ids | wc -l`
    NOTdetected_genuine_IC=`zcat ./H_tmerged/$name.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id | sort | uniq | grep "\S" | wc -l`
    NOTdetected_genuine_TX=`cat $file | grep -Fwf H_enhancers_tx_ids_NOTdetected_in_genuinemT.ids | awk '{print $4}' | sort | uniq | grep "\S" | wc -l`
    echo -e "$target_category\t$name\t$all_IC\t$all_TX\t$targeted_IC\t$targeted_TX\t$detected_genuine_IC\t$detected_genuine_IC_GENCODE\t$NOTdetected_genuine_IC\t$detected_genuine_TX\t$detected_genuine_TX_GENCODE\t$NOTdetected_genuine_TX" >> H_target_detection_results.tsv
    echo "++ Done ++"
  done < ./H_enhancers.config
  

###################################
# Run catalog specificity analysis  
###################################
# Remove old results
rm -r Catalog_specificity/

# Create directory tree
mkdir Catalog_specificity/

# Move to working dir
cd Catalog_specificity/

echo "Analyzing files..."

# Extract transcirpt_ids from contrains fiield of tmenrge output (has only one tx_id in contains tmerge output) #| grep -v ","
## For IC not detected in genuine
zcat ../H_tmerged/H_concat_true_longNonCoding.NOTdetectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id,contains | sort | uniq | grep "\S" > H_extracted_transcripts.ids
## For IC detected in genuine
zcat ../H_tmerged/H_concat_true_longNonCoding.detectedInGenuine.slice.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id,contains | sort | uniq | grep "\S" > H_extracted_transcripts_detected.ids
## For IC from merged-lncRNAs
zcat ../H_tmerged/H_concat_true_longNonCoding.tmerged.gtf.gz | extract.gtf.tags.sh - transcript_id,contains | sort | uniq | grep "\S" > H_extracted_transcripts_mergedRNAs.ids


# Create table with tx_ids and catalog name
for file in ../H_catalogs/*bed12
  do
     name=`echo $file | awk -F'/' '{print $NF}' | awk -F '.' '{print $1}'`
     # do not include concatenated catalogs
     if [[ "$name" == "H_concat_catalogs" ]]; then
     continue
     fi
     cat $file | awk -v catalog=$name '{print $4 "\t" catalog}' >> H_transcripts_with_catalog_names.tsv
  done
  
echo "++ Done ++"  
```

# Load R libraries
```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(ggplot2,
               scales,
               dplyr,
               tidyr,
               ggrepel,
               ggh4x)
```

# Load, transform and plot the data
```{r}
# Clean the env
rm(list = ls())

# Load data
## Transcript_ids not detected in genuine (NOT in GENCODE 47)
df_H_extracted_transcripts <- read.table(".temp_s12b/Catalog_specificity/H_extracted_transcripts.ids",
                                       header=F, sep="\t") %>%
  rename(H_intronChain_id="V1",
         H_transcript_id="V2")

## Preview
df_H_extracted_transcripts

## Transcript_ids detected in genuine (in GENCODE 47)
df_H_extracted_transcripts_detected <- read.table(".temp_s12b/Catalog_specificity/H_extracted_transcripts_detected.ids",
                                       header=F, sep="\t") %>%
  rename(H_intronChain_id="V1",
         H_transcript_id="V2")

## Preview
df_H_extracted_transcripts_detected


#########################################
## Transcript_ids with catalog names
df_H_transcripts_with_catalogs <- read.table(".temp_s12b/Catalog_specificity/H_transcripts_with_catalog_names.tsv",
                                       header=F, sep="\t") %>%
  rename(H_transcript_id="V1",
         H_catalog="V2") %>% 
  filter(H_catalog == "bigTranscriptome" | H_catalog == "fantomCat" | H_catalog == "gencode20+" | H_catalog == "miTranscriptome" | H_catalog == "NONCODE" | H_catalog == "refSeq") %>% 
  mutate(H_catalog = ifelse(H_catalog=="bigTranscriptome","bigTranscriptome", H_catalog)) %>%
  mutate(H_catalog = ifelse(H_catalog=="gencode20+","GENCODEv20+", H_catalog)) %>%
  mutate(H_catalog = ifelse(H_catalog=="fantomCat","fantomCat", H_catalog)) %>%
  mutate(H_catalog = ifelse(H_catalog=="miTranscriptome","miTranscriptome", H_catalog)) %>%
  mutate(H_catalog = ifelse(H_catalog=="NONCODE","NONCODE", H_catalog)) %>%
  mutate(H_catalog = ifelse(H_catalog=="refSeq","refSeq", H_catalog))

## Preview
df_H_transcripts_with_catalogs

## Check catalogs
df_H_transcripts_with_catalogs %>% 
  distinct(H_catalog)

#########################################
# Join tables
df_H_joined_tables <- df_H_extracted_transcripts %>% 
  left_join(x=.,
            y=df_H_transcripts_with_catalogs)

# Preview
df_H_joined_tables
##################
# Join tables
df_H_joined_tables_detected <- df_H_extracted_transcripts_detected %>% 
  left_join(x=.,
            y=df_H_transcripts_with_catalogs)

# Preview
df_H_joined_tables_detected


#########################################
# Plot this - catalog composition


cbPalette <- c("lightgrey", "darkgrey","#3E506C","#50868d","#58508d","#bc5090","#ff6362","#ffa602")


df_specific_IC <- df_H_joined_tables %>%
  filter(!is.na(H_catalog)) %>%  # to filter out IC_ids that were merged
  summarise(.by="H_intronChain_id", count = n()) %>% 
  filter(count == 1) %>% 
  select(H_intronChain_id) %>% # to filter out those not merged but still present in more than one set (there are 14 ids like this from fantomCat and Gencode+)
  rbind(df_H_joined_tables %>% # here we filter those that were merged but consist of multiple transcripts from the same catalog
          mutate(category=ifelse((is.na(H_catalog)), "non specific", "specific")) %>% 
          filter(category=="non specific") %>% 
          select(H_intronChain_id, H_transcript_id) %>% 
          separate_rows(H_transcript_id, sep = ",") %>%
          left_join(x=.,
                    y=df_H_transcripts_with_catalogs,
                    by="H_transcript_id") %>% 
          summarise(.by=H_intronChain_id,
                    unique_count=length(unique(H_catalog))) %>% 
          filter(unique_count==1) %>% 
          select(H_intronChain_id)) %>% 
  unique()


df_specific_IC_detected <- df_H_joined_tables_detected %>%
  filter(!is.na(H_catalog)) %>%  # to filter out IC_ids that were merged
  summarise(.by="H_intronChain_id", count = n()) %>% 
  filter(count == 1) %>% 
  select(H_intronChain_id) %>% # to filter out those not merged but still present in more than one set (there are 14 ids like this from fantomCat and Gencode+)
  rbind(df_H_joined_tables %>% # here we filter those that were merged but consist of multiple transcripts from the same catalog
          mutate(category=ifelse((is.na(H_catalog)), "non specific", "specific")) %>% 
          filter(category=="non specific") %>% 
          select(H_intronChain_id, H_transcript_id) %>% 
          separate_rows(H_transcript_id, sep = ",") %>%
          left_join(x=.,
                    y=df_H_transcripts_with_catalogs,
                    by="H_transcript_id") %>% 
          summarise(.by=H_intronChain_id,
                    unique_count=length(unique(H_catalog))) %>% 
          filter(unique_count==1) %>% 
          select(H_intronChain_id)) %>% 
  unique()


#########################################
# Plot this - catalog specificity joined with composition

df_H_joined_tables %>% 
  mutate(category=ifelse((H_intronChain_id %in% df_specific_IC$H_intronChain_id), "specific", "non specific")) %>%  
  select(H_intronChain_id, category) %>% 
  unique() %>% 
  group_by(category) %>% 
  summarise(.groups = "keep", count=n()) %>% 
  ungroup() %>% 
  mutate(percentage=count/sum(count)) %>%
  mutate(H_catalog=ifelse((category=="specific"), "Catalog-specific", "Shared across catalogs")) %>% 
  mutate(category="Not detected") %>% 
  rbind(df_H_joined_tables %>%
          mutate(category=ifelse((H_intronChain_id %in% df_specific_IC$H_intronChain_id), "specific", "non specific")) %>%  
          select(H_intronChain_id, H_transcript_id, category) %>% 
          separate_rows(H_transcript_id, sep = ",") %>%
          left_join(x=.,
                    y=df_H_transcripts_with_catalogs,
                    by="H_transcript_id") %>%
          select(H_intronChain_id, H_catalog, category) %>% 
          unique() %>% 
          group_by(H_catalog, category) %>% 
          summarise(.groups = "keep", count=n()) %>% 
          group_by(category) %>%
          mutate(percentage=count/sum(count)) %>%
          filter(category=="specific") %>%           # comment out to see composition of non specific
          mutate(category="Catalog composition")) %>% 
  rbind(df_H_joined_tables_detected %>% 
          mutate(category=ifelse((H_intronChain_id %in% df_specific_IC_detected$H_intronChain_id), "specific", "non specific")) %>%  
          select(H_intronChain_id, category) %>% 
          unique() %>% 
          group_by(category) %>% 
          summarise(.groups = "keep", count=n()) %>% 
          ungroup() %>% 
          mutate(percentage=count/sum(count)) %>%
          mutate(H_catalog=ifelse((category=="specific"), "Catalog-specific", "Shared across catalogs")) %>% 
          mutate(category="Detected")) %>% 
  ## Plot
  ggplot(aes(x=factor(category, levels=c("Detected",
                                         "Not detected",
                                         "Catalog composition")), y=percentage, fill=factor(H_catalog, levels=c("Catalog-specific", "Shared across catalogs",
                                                                                                                "bigTranscriptome", "fantomCat", "miTranscriptome",
                                                                                                                "refSeq", "GENCODEv20+", "NONCODE")))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales::comma(count)),
            position = position_stack(vjust = 0.5),
            size = 3.5) +
  scale_fill_manual(values = cbPalette) +
  theme_bw() +
  ylab("Percentage") +
  scale_y_continuous(labels=percent, lim=c(0,1)) +
  theme(legend.position="top") +
  theme(axis.text.x = element_text(size = 12, colour = "black"), #, angle = 60, hjust = 1,
        axis.ticks.x = element_blank(),
        axis.text.y = element_text(size = 12,  colour = "black"),
        legend.text = element_text(size = 12),
        plot.title = element_text(size = 15, hjust = 0.5),
        legend.title = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        strip.text.x = element_text(size = 18),
        strip.text.y = element_text(size = 18)) -> plot_figure_s12b


# Preview plot
plot_figure_s12b
```

# Save plot - catalog specificity with composition
```{r}
pdf(file="figure_s12b.pdf", width = 8, height = 6)
plot_figure_s12b
```
